GTP_GUIDELINE (Clean & Updated Version)

1. Purpose of the App Layer

The App layer receives a fully parsed HTTP_Request from the Core and returns a fully constructed HTTP_Response.
It does not manage sockets, poll(), timeouts, chunk parsing, or network I/O.
The Core handles all of that before and after calling the App.

The App is responsible for:
- Routing (virtual host + location matching)
- Method allow-lists
- Path normalization + secure root mapping
- Selecting resource type (static file, directory, CGI, upload)
- Applying error pages and redirects
- Building and returning the response

2. Routing Overview
2.1 Virtual Host (Server block) Selection
- Server is selected by matching Host: header against server_name.
- First server is used as fallback.
- Exact-match behaviour (no port stripping) is intentional.

2.2 Location Matching
- Longest-prefix match on the request path.
- Location only matches when prefix boundary is valid.
- If no location matches → server-level defaults apply.

2.3 Allowed Methods → 405
- Methods come from allowedMethods (location overrides server).
- Default = GET, POST.
- If method not allowed:
  - Respond with 405 Method Not Allowed
  - Set Allow: header listing valid methods

3. Path Normalization & Filesystem Mapping
3.1 Target Parsing
- Origin-form or absolute-form URL parsing (path + query).
- "*" → treated as path “/”.

3.2 Root Mapping
- makeFilesystemPath maps location root + request path.
- normalizePath performs:
  - Component splitting
  - Handling of . and ..
  - Ensuring the path stays inside the configured root
    → escape attempts return 403 Forbidden

3.3 Notes
- Percent-decoding (%XX) is intentionally not implemented.
- This does not affect security because traversal is enforced at filesystem level.

4. Resource Types
The App classifies requests into these categories:

4.1 Static File
- Regular file → returned with:
  - 200 OK
  - MIME type (simple extension map)
  - Body = file contents
- HEAD → same headers, empty body

4.2 Directory
- Try index files (index directive)
- If not found:
  - If autoindex on → return generated directory listing
  - Else → 403 Forbidden

4.3 CGI
- Triggered by file extension matching cgi_pass
- Implementation includes:
  - Building full CGI environment
  - fork/exec interpreter + script
  - timeout handling
  - capturing stdout
  - header/body parsing (Content-Type or Location required)
- Invalid CGI output → 502 Bad Gateway
- Timeout → 504 Gateway Timeout

4.4 Uploads (Simple)
- If location has upload_store and request is POST:
  - Filename extracted from path
  - Sanitization of filename
  - Prevent overwriting (409)
  - Successful upload → 201 Created
- Multipart/form-data is intentionally not implemented
  → returns 501 Not Implemented

5. Error Pages
- error_page mapping supports multiple codes → single URI (NGINX-style)
- If custom error page exists:
  - Body replaced with error file contents
  - Status code is preserved
- If missing/unreadable → fall back to built-in minimal HTML error page

6. Redirection (return)
- If a location/server defines: return <status> <target>;
- App immediately responds with that redirect.
- Only 3xx statuses are accepted; otherwise fallback to 302.

7. Connection Handling
- If request uses keep-alive:
  - Connection: keep-alive
- Otherwise:
  - Connection: close
- HEAD requests remove body and Content-Length.

8. Out-of-Scope Items (Intentionally Not Implemented)
- multipart/form-data upload parsing
- percent-decoding of URL path
- advanced virtual-host port-stripping logic
- realpath() resolution
- auto-logging system
