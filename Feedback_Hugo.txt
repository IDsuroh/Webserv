Config.cpp

void Config::parse()

    Detect # only when outside quotes (to avoid cutting valid strings).

void Config::tokenize(const std::string& contents, std::vector<std::string>& tokens)

    "My site name" → will be split into 3 tokens ("My", "site", "name") because there is no quote handling. Allow "some value with spaces" or '...' as a single token.

static void handleListen(Server& srv, const std::vector<std::string>& tokens, size_t& i)

    const std::string arg = tokens[i++]; can be replaced with const std::string& arg = tokens[i]; ++i;. It’s more efficient.

    NGINX allows listen 8080 8081; and the function doesn’t handle this situation — currently only "8080" is stored (incomplete).

static void handleServerName(Server& srv, const std::vector<std::string>& tokens, size_t& i)

    Currently accepts server_name ; (consider whether you want to throw an error).

// I think the following version of the function is better.
static void handleErrorPage(Server& srv, const std::vector<std::string>& tokens, size_t& i) {

    if (i + 2 >= tokens.size())
        throw std::runtime_error("Incomplete error_page directive");

    const std::string& error_code = tokens[i++];
    const std::string& uri = tokens[i++];

    if (i >= tokens.size() || tokens[i] != ";")
        throw std::runtime_error("Missing ';' after error_page");
    ++i;

    srv.error_pages[error_code] = uri;
}

    Does not support multiple codes: nginx allows error_page 404 500 502 /50x.html;. Your code fails in that case (reads error_code="404", uri="500" and expects ; — sees a path and throws).

    No URI validation: accepts any string (generally ok), but you could require it to start with / or http://.../https://....

static void parseLocationBlock(const std::vector<std::string>& tokens, size_t& i, Location& loc)

    No bounds-check before reading key: if the file ends inside the block, std::string key = tokens[i++] accesses out-of-bounds → UB/crash.

    Error consumes ; correctly, but the message has no context (line) — fine for now.

    Loss of cardinality: storing everything “joined” (e.g. methods GET POST → "GET POST") forces you to split again at runtime.

    Duplicate directives: simple assignment silently overwrites; decide whether to forbid or “last wins”.

    Accidental nested blocks: if someone puts a { inside a location by mistake, the loop will treat it as a normal argument and only break later.

    ChatGPT provided a more robust version.

static void handleGenericDirective(Server& srv, const std::string& key, const std::vector<std::string>& tokens, size_t& i)

    Silent overwrite: if the same key appears twice, the last one wins with no warning.

    Loss of cardinality: everything becomes a string; at runtime you must re-split for multi-value directives (e.g. index, methods).

    Unknown directives pass: typos like rooot will be accepted and stored — hard to debug.

    No validation of number/type of arguments: client_max_body_size without a value, or autoindex foo bar, are accepted until they blow up later.

    Empty args: key ; is accepted (will be "") — probably unwanted for most directives.

ServerRunner.cpp

ServerRunner::ServerRunner(const std::vector<Server>& servers)

    (Optional) validate here that there is at least one valid listen in the configs; if not, throw a clear exception (facilitates fail-fast).

void ServerRunner::run()

    Why use -1 in int n = poll(&_fds[0], _fds.size(), -1);? Wouldn’t it be safer to use a defined timeout? I’ve read that it is…

void setupListeners(const std::vector<Server>& servers, std::vector<Listener>& outListeners)

    If setupPollFds() registers one pollfd per Listener, you’ll insert the same fd multiple times into poll() (one for each Listener sharing that fd). This is inefficient and may complicate logic.
    Correct: add only one pollfd per unique fd.

    It’s almost fine for the 42 scope (no virtual hosts), as long as your config doesn’t repeat the same listen in more than one server{}. If repeated, your code will create multiple Listener objects with the same fd, which is confusing and can duplicate entries in poll().

Minimal adjustments:

    Reject duplicates among server blocks (or ignore subsequent ones with a warning).

    Ensure exactly one Listener per unique fd in outListeners.

// Suggested improvement for the next version:
void ServerRunner::setupPollFds() {
    _fds.clear();                        // to have a clean list on multiple calls
    _fds.reserve(_listeners.size());

    std::set<int> added;
    for (std::size_t i = 0; i < _listeners.size(); ++i) {
        int fd = _listeners[i].fd;
        if (!added.insert(fd).second) continue; // checks and inserts in 1 line!

        struct pollfd p;
        p.fd = fd;
        p.events = POLLIN; 
        p.revents = 0;
        _fds.push_back(p);
    }
}

int openAndListen(const std::string& spec)
	// What if the evaluator sets an IP with only the host and without the port? In that case, what can we do?

void ServerRunner::handleEvents()

    Curiosity: you have for (std::size_t i = _fds.size(); i-- > 0; ). ChatGPT pointed me to a different way: swap the current pfd with the last before deleting it (the new last), avoiding index shifts and skipping items.

void ServerRunner::acceptNewClient(int listenFd, const Server* srv)

    FD_CLOEXEC on the client fd (good practice) — closes the fd in execve:

        fcntl(clientFd, F_SETFD, fcntl(clientFd, F_GETFD) | FD_CLOEXEC);

******************************** NOTES TO CHECK*******************How about for Mac_OS?


ServerRunner (continuation).cpp

void ServerRunner::readFromClient(int clientFd)

    Connection “freezes” in S_READY
        If there’s no body (BR_NONE), you do:

            connection.state = S_READY;
            return;
        But the pollfd still has events = POLLIN.
        No new event will occur → the request stalls forever.
        Fix: as soon as you enter S_READY, produce the response (or call the layer that does) and change the fd to POLLOUT + S_WRITE.

    Limits → defense against slowloris / DoS attacks
    Currently, readBuffer can grow indefinitely waiting for \r\n\r\n.
        Add limits:

        Max header size (e.g., 8–16 KiB): if exceeded before finding \r\n\r\n → send 431/400 and close.

        Timeout per state: if you track last_activity, expire S_HEADERS/S_BODY after a threshold.

    Avoid unnecessary copies
    Instead of substr + swap, use

        connection.readBuffer.erase(0, delim + 4);
        (no extra string allocation).

    Be careful with errno usage in both read and write (must capture immediately before other calls).
-------------------------------------------- done -----------------------------------------------------------
void ServerRunner::writeToClient(int clientFd)

    Doesn’t handle EAGAIN / EWOULDBLOCK
        On a non-blocking socket, write() may return -1 with errno = EAGAIN, meaning “can’t send more now”.
        If you close immediately, you’ll cut the response mid-way.

    Doesn’t handle EINTR
        If the write is interrupted by a signal, you must retry.

    Always closes at the end
        In HTTP/1.1, the default is to keep the connection alive if the client requested it.
        You should only close if Connection: close or on error.

    Missing pollfd update
        When the buffer becomes empty and you’re keeping the connection alive, you must switch events back to POLLIN (to read the next request).

    Improved version example:

void ServerRunner::writeToClient(int clientFd) {
    std::map<int, Connection>::iterator it = _connections.find(clientFd);
    if (it == _connections.end()) return;

    Connection& c = it->second;

    while (!c.writeBuffer.empty()) {
        ssize_t n = ::write(clientFd, c.writeBuffer.c_str(), c.writeBuffer.size());
        if (n > 0) {
            c.writeBuffer.erase(0, static_cast<std::size_t>(n));
            continue;
        }
        if (n < 0) {
            if (errno == EINTR) continue;                     // retry
            if (errno == EAGAIN || errno == EWOULDBLOCK) {    // can't send more now
                // stay registered for POLLOUT, retry next poll()
                return;
            }
            closeConnection(clientFd);                        // real error
            return;
        }
        // n == 0 → remote closed
        closeConnection(clientFd);
        return;
    }

    // Entire buffer sent
    if (c.request.keep_alive && !c.response.close) {
        // Reuse connection: wait for next request
        c.state = S_HEADERS;
        c.readBuffer.clear();
        c.request = HTTP_Request();
        c.response = HTTP_Response();

        for (size_t i = 0; i < _fds.size(); ++i) {
            if (_fds[i].fd == clientFd) {
                _fds[i].events = POLLIN;   // back to listening
                break;
            }
        }
    } else {
        closeConnection(clientFd); // terminate if not keep-alive
    }
}

void ServerRunner::closeConnection(int clientFd)

    Avoid O(n) complexity when removing/updating events
    Maintain a map fd → index in _fds (update when erasing with swap-and-pop):

    // O(1) removal (swap with back + pop), but update index for swapped fd
    std::size_t idx = fdIndex[fd];
    std::size_t last = _fds.size() - 1;
    std::swap(_fds[idx], _fds[last]);
    fdIndex[_fds[idx].fd] = idx;
    _fds.pop_back();
    fdIndex.erase(fd);

HttpBody.cpp

BodyResult consume_body_content_length(Connection& connection, std::size_t max_body, int& status, std::string& reason)

    The usual substr + swap pattern works and may even shrink capacity,
    but it performs a full allocation/copy.
    
    Simpler alternatives:

    connection.readBuffer.erase(0, take);
    (clearer and sufficient, also O(n)).

BodyResult consume_body_chunked(Connection& connection, std::size_t max_body, int& status, std::string& reason)

    Line length limit (SIZE and TRAILERS)
    To defend against DoS, enforce a max number of bytes per line (e.g., 8–16 KB).
    If find("\r\n") doesn’t appear within that limit → return 413 or 400.

    Buffer management (same as previous)
    substr + swap works but allocates/copies.
    erase(0, n) is simpler; for optimized performance, you can keep a read offset and compact occasionally.

HttpParser.cpp

bool isTokenChar(unsigned char c)

    std::isalnum(c) depends on the current locale.

    In pt_PT.UTF-8, for instance, isalnum('ç') may return true — which is not valid in HTTP (tchar is ASCII-only).

Solution:

inline bool isTokenChar(unsigned char c) {
    if (c > 0x7F) return false; // tchar is ASCII only

    // ALPHA / DIGIT (ASCII only, no locale dependency)
    if ((c >= '0' && c <= '9') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z'))
        return true;

    switch (c) {
        case '!': case '#': case '$': case '%': case '&': case '\'': case '*':
        case '+': case '-': case '.': case '^': case '_': case '`': case '|': case '~':
            return true;
    }
    return false;
}

bool parseRequestLine(const std::string& line, HTTP_Request& request, int& outStatus, std::string& outReason)

    Possible improvements (RFC / real-world cases)

    Trailing \r → often appears as "HTTP/1.1\r" → strip final CR before comparing.

    Multiple spaces / HTAB between fields → RFC defines SP, but real clients use multiple or tabs. Accept 1+ SP/HTAB.

    Extra characters after version → "HTTP/1.1 junk" should be 400 (ignore optional CR only).

    Target validation → request-target cannot contain spaces or tabs. If it does → 400 (or 414 if too long). Reject non-ASCII control bytes (0x00–0x1F, 0x7F).

    Special methods

    OPTIONS * (asterisk-form) is valid.

    CONNECT accepts authority-form (host:port), validation can be deferred.

    Locale/ASCII → maintain ASCII-only isTokenChar (no locale dependence).

bool parseHeadersBlock(const std::string& block, HTTP_Request& request, int& outStatus, std::string& outReason)

    Essential validations (fix 400/413/501 misclassifications or invalid acceptances):

    Validate header name as ASCII token
    Currently any characters before : are accepted. Reject names with spaces, /, :, or non-ASCII chars.

    for (std::size_t j = 0; j < k.size(); ++j) {
        if (!isTokenChar(static_cast<unsigned char>(k[j]))) {
            outStatus = 400; outReason = "Bad Request"; return false;
        }
    }
    obs-fold without previous header → 400

    if (current[0] == ' ' || current[0] == '\t') {
        if (lastKey.empty()) { outStatus = 400; outReason = "Bad Request"; return false; }
    }
    Content-Length: avoid locale, validate numeric and duplicates

    Replace std::isdigit with ASCII test.

    Verify endptr from strtoul.

    If repeated, all values must be identical.

    for (std::size_t i = 0; i < s.size(); ++i)
        if (s[i] < '0' || s[i] > '9') BAD400;

    char* endp = 0; errno = 0;
    unsigned long v = std::strtoul(s.c_str(), &endp, 10);
    if (errno == ERANGE || endp == s.c_str() || *endp != '\0') { /* 400 or 413 */ }

    // Multiple identical values ("123, 123")
    std::string raw = clit->second;
    std::string first;
    std::istringstream iss(raw);
    std::string part;
    while (std::getline(iss, part, ',')) {
        part = trim(part);
        if (part.empty()) BAD400;
        if (first.empty()) first = part;
        else if (part != first) BAD400;
    }
    Transfer-Encoding: tokenize, require “chunked” last, reject others

    bool hasTE = (teit != request.headers.end());
    bool hasCL = (clit != request.headers.end());

    if (hasTE) {
        std::vector<std::string> codings;
        std::istringstream iss(toLowerCopy(teit->second));
        std::string tok;
        while (std::getline(iss, tok, ',')) {
            tok = trim(tok);
            if (!tok.empty()) codings.push_back(tok);
        }
        if (hasCL) BAD400; // anti-smuggling check (good)

        bool seenChunked = false;
        for (std::size_t i = 0; i < codings.size(); ++i) {
            if (codings[i] == "chunked") {
                if (i != codings.size() - 1) BAD400; // must be last
                seenChunked = true;
            } else {
                outStatus = 501; outReason = "Not Implemented"; return false;
            }
        }
        if (seenChunked) request.body_reader_state = BR_CHUNKED;
        else { outStatus = 501; outReason = "Not Implemented"; return false; }
    }

    Connection: close — avoid false positives with find
    Tokenize by commas/spaces. find("close") can match “disclose”.

    request.keep_alive = true; // default 1.1
    if (chit != request.headers.end()) {
        std::istringstream iss(toLowerCopy(chit->second));
        std::string tok;
        while (std::getline(iss, tok, ',')) {
            tok = trim(tok);
            if (tok == "close") { request.keep_alive = false; break; }
        }
    }
    Duplicate Host header with differing values → 400
    Even though merging with commas handles it, better to detect differing duplicates before coalescing:

    Quick fix: if k == "host" and already exists with a different value → 400.

bool parse_head(const std::string& head, HTTP_Request& request, int& status, std::string& reason)

    Size limits (DoS defense):

    Limit total header size (8–16 KiB).

    Limit request-line length (4–8 KiB).
    If exceeded → 431 Request Header Fields Too Large (or 400/413 per project policy).

bool extract_next_head(std::string& buffer, std::string& out_head)

    Avoid infinite loop for malformed buffers
    If buffer contains only \r or incomplete \r\n\r, it will loop returning false forever. Correct behaviour (wait for more data), but ensure caller has timeout/size limit.

    Avoid extra copies
    Use erase(0, drop) instead of substr + swap.

    std::string build_simple_response(int status, const std::string& reason, const std::string& body)

    Add Date header — RFC 7231 recommends including it.

    Keep-Alive support — if sending a response under a keep-alive context, change "Connection: close" to "Connection: keep-alive".

    if (request.keep_alive)
        oss << "Connection: keep-alive\r\n";
    else
        oss << "Connection: close\r\n";