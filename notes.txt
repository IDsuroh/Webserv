- Implement try catch method in the int main to avoid possibilities of compile errors

1. Do I already implement virtual hosts?
No. Not yet and we do not need to implement.
if we are not implementing vhost, we are;
	a) not going to have a different behavior based on the Host: header.
	b) we are implmenting one website per running webserv process (or per config file).

if we are not serving vhost, we are serving:
a. one webserv process + one config file -> one logical website.
b. which can still
	a. have multiple locations (e.g. /, /images, /cgi-bin)
	b. serve static files
	c. run CGI
	d. do autoindex
	e. etc.
	f. However, it will not switch between multiple independent server blocks

2. Why copy the servers vector in ServerRunner ctor?
ServerRunner::ServerRunner(const std::vector<Server>& servers)
    : _servers(servers) {}

‚ÄúWe copy the std::vector<Server> into ServerRunner so the runner owns a stable snapshot of the configuration. That avoids dangling references if the original container goes out of scope and prevents unexpected mutations from elsewhere. Since configs are small and built once at startup, the copy cost is negligible in C++98.‚Äù

-----------------------------------------------------------------------------------------------

Things to clear out

1. What is a virtual host?

2. What is the difference between this virtual host and the virtual host that we are refering to when it comes to IP:ports from different servers? 

What is a virtual host?
A logical website configuration (one Server in your config) that can share the same process, IP, or even the same port with others, and is picked using Host and listen info.

Difference from IP:port ‚Äúvirtual host‚Äù idea?

IP:port separation: different sites on different listener sockets (127.0.0.1:8080 vs 127.0.0.1:8081). The kernel already tells you which one you‚Äôre on.

Name-based virtual host: multiple Server configs share the same listener, and the Host header (and server_name) decides which one handles the request.


-----------------------------------------------------------------------------------------------

CURL COMMANDS THAT WE CAN USE

1Ô∏è‚É£ Basic GET (server works)
	curl -i http://127.0.0.1:8080/
	->	HTTP/1.1 200 OK

2Ô∏è‚É£ GET non-existing resource ‚Üí 404
	curl -i http://127.0.0.1:8080/does-not-exist
	-> HTTP/1.1 404 Not Found

3Ô∏è‚É£ Method not allowed ‚Üí 405 + Allow
	curl -i -X POST http://127.0.0.1:8080/
	-> HTTP/1.1 405 Method Not Allowed
	Allow: GET

4Ô∏è‚É£ Upload small body (POST)
	curl -i -X POST http://127.0.0.1:8080/upload -d "hello world"
	HTTP/1.1 201 Created
	Location: /upload

5Ô∏è‚É£ Upload large body (Content-Length)
	curl -i -X POST http://127.0.0.1:8080/upload --data-binary @./www/stress/large.bin
	Expected:
		201 Created or
		413 Payload Too Large (both acceptable, depending on config)

6Ô∏è‚É£ Upload conflict ‚Üí 409
	curl -i -X POST http://127.0.0.1:8080/upload -d "hello again"
	HTTP/1.1 409 Conflict

7Ô∏è‚É£ DELETE existing file
	First, make sure file exists:
	ls ./www/trash
	curl -i -X DELETE http://127.0.0.1:8080/trash/file.txt
	HTTP/1.1 204 No Content

8Ô∏è‚É£ DELETE non-existing file ‚Üí 404
	curl -i -X DELETE http://127.0.0.1:8080/trash/nope.txt
	HTTP/1.1 404 Not Found

9Ô∏è‚É£ Chunked POST (manual chunk framing)
	printf 'b\r\nhello world\r\n0\r\n\r\n' | curl -i --http1.1 -X POST http://127.0.0.1:8080/upload -H "Transfer-Encoding: chunked" --data-binary @-
	HTTP/1.1 201 Created

üîü Keep-Alive vs Close (HTTP/1.1)
	Force close:
	curl -i http://127.0.0.1:8080/ -H "Connection: close"
	Connection: close
	Default keep-alive:
	curl -i --http1.1 http://127.0.0.1:8080/
	Connection: keep-alive

1Ô∏è‚É£1Ô∏è‚É£ Multiple requests on same connection
	curl -i --http1.1 http://127.0.0.1:8080/ http://127.0.0.1:8080/does-not-exist