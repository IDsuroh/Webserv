To do things for Webserv.

1. Not implemented / still stubs (based on what’s in the tree)

2. No concrete HTTP request parser yet (request-line + header folding + canonicalization).

3. No Host header validation.

4. No body readers (Content-Length / chunked) or client_max_body_size enforcement.

5. No per-connection HTTP state machine (HEADERS → BODY → READY → WRITE).

6. No timeouts (header/read/write/idle).

7. No response builder (status line, headers, error pages) or keep-alive logic.

8. No “app side” callback interface to hand a ready HttpRequest to your partner and receive an HttpResponse.


Tightened plan — fix & focus Part A (“HTTP Core”)

A. Define clear request/response types (1 file, 1 hour)

	struct HttpRequest { method, target, version, headers (std::map<std::string,std::string> with lowercase keys), host, content_length, transfer_encoding, body_reader_state, keep_alive, ... }

	struct HttpResponse { status, reason, headers, body; bool close; }

	Add enum ConnState { S_HEADERS, S_BODY, S_READY, S_WRITE, S_CLOSED }; to Connection.

B. Wire a minimal state machine in ServerRunner (incremental)

	1. HEADERS parsing (line-by-line)

		In readFromClient(): read into readBuffer; parse CRLF-delimited lines until you hit the blank line.

		Parse request line: METHOD SP request-target SP HTTP/1.1\r\n → 400 on format error.

		Collect headers; lowercase header keys; coalesce folded values (if any).

		Validate: HTTP/1.1 requires Host → 400 if missing or malformed.

		Set Connection: keep-alive/close behavior (HTTP/1.1 default keep-alive unless header says close).

		Transition: if there’s a body to come → S_BODY; else → S_READY.

	2. BODY readers (incremental, non-blocking)

		Implement mutually exclusive readers:

		Content-Length: read exactly N bytes across polls; overflow → 413; if more data arrives, keep it for next request on same connection.

		Transfer-Encoding: chunked: incremental chunk decoder (size line in hex, chunk data, CRLF, trailers → you may ignore/collect); unsupported TE → 400 or 501.

		client_max_body_size: ask partner’s config facade for the value (or expose from Server/Location). Enforce before/while buffering → 413 with close unless keep-alive allowed.

		On completion → S_READY.

	3. READY → call “app side”

		Define an interface the “app” owns, e.g. HttpResponse App::handle(const HttpRequest&, const Server& /*vhost*/, const Location& /*match*/);

		For now, stub it in ServerRunner as a lambda or placeholder that returns 200 text/plain “Hello from core”.

		Transition to S_WRITE with a serialized response (see next).

	4. WRITE (response serializer)

		Build: HTTP/1.1 <status> <reason>\r\nHeaders...\r\n\r\n<body>

		Always send Date, Server: webserv, Connection: keep-alive/close, Content-Length (unless you implement response chunked for streaming).

		Honor keep-alive: after write completes → reset connection buffers and go back to S_HEADERS or close if close was chosen.

	5. Timeouts

		Track per-connection timestamps:

			header timeout (e.g., 10s without completing headers) → 408 + close

			body idle timeout (e.g., 15–30s between reads) → 408 + close

			write timeout (e.g., 10–15s) → close

			This satisfies “A request should never hang indefinitely.”

	6. Error handling

		Map parse errors to status codes: 400 (bad syntax), 413 (body too large), 405 (later, when app rejects method), 404/500 from app, and default error pages if partner doesn’t supply custom ones in config.

		Ensure you can send an error from any state (e.g., mid-headers → generate minimal response and flip to S_WRITE).

	7. HTTP correctness polish

		Be strict on Content-Length vs Transfer-Encoding conflicts (RFC: if both, TE wins for 1.1; or reject—document your choice).

		Method token + path normalization (basic sanity; partner will do full mapping).

C. Things you don’t decide (leave to partner / “app side”)

vhost pick (listener + Host), location match (longest-prefix), method allow lists (405 + Allow), path/root mapping & normalization, static files & MIME, index/autoindex, custom error_page, CGI + uploads (multipart), and logging. You just give them a validated HttpRequest and expect a complete HttpResponse back. (All defined in the subject’s config and features.)


You — HTTP Core (finalized checklist)
- Per-connection state machine and buffers.
- Request line + headers parser (lowercase keys, strict CRLF)..
- Host header validation (HTTP/1.1).
- Keep-alive/close negotiation.
- Body readers: Content-Length and chunked (incremental).
- client_max_body_size enforcement (read from config / partner API).
- Timeouts: header/body/write/idle.
- Response serializer (+ default error pages and accurate status codes).
- Error path from any state.
- Minimal “app stub” call to prove hand-off.

Partner — App/Routing/Resources (parallelizable now)
- Vhost select (listener + Host).
- Location match (longest prefix) and allowed methods → 405 + Allow.
- Path normalization + root mapping (prevent .. traversal).
- Static file serving + MIME; index files; autoindex pages.
- error_page mapping to custom pages.
- CGI runner (env, timeouts) and uploads (multipart).
- Config validation & defaults; logging.

-----------------------------------------------------------------------------------------------
- Implement try catch method in the int main to avoid possibilities of compile errors

1. Do I already implement virtual hosts?
No. Not yet and we do not need to implement.
if we are not implementing vhost, we are;
	a) not going to have a different behavior based on the Host: header.
	b) we are implmenting one website per running webserv process (or per config file).

if we are not serving vhost, we are serving:
a. one webserv process + one config file -> one logical website.
b. which can still
	a. have multiple locations (e.g. /, /images, /cgi-bin)
	b. serve static files
	c. run CGI
	d. do autoindex
	e. etc.
	f. However, it will not switch between multiple independent server blocks

2. Why copy the servers vector in ServerRunner ctor?
ServerRunner::ServerRunner(const std::vector<Server>& servers)
    : _servers(servers) {}

“We copy the std::vector<Server> into ServerRunner so the runner owns a stable snapshot of the configuration. That avoids dangling references if the original container goes out of scope and prevents unexpected mutations from elsewhere. Since configs are small and built once at startup, the copy cost is negligible in C++98.”

-----------------------------------------------------------------------------------------------

Things to clear out

1. What is a virtual host?

2. What is the difference between this virtual host and the virtual host that we are refering to when it comes to IP:ports from different servers? 

What is a virtual host?
A logical website configuration (one Server in your config) that can share the same process, IP, or even the same port with others, and is picked using Host and listen info.

Difference from IP:port “virtual host” idea?

IP:port separation: different sites on different listener sockets (127.0.0.1:8080 vs 127.0.0.1:8081). The kernel already tells you which one you’re on.

Name-based virtual host: multiple Server configs share the same listener, and the Host header (and server_name) decides which one handles the request.


-----------------------------------------------------------------------------------------------

After Merge:

// Somewhere you will later fork/exec CGI:
/*
pid_t pid = fork();
if (pid == 0) {
    // Child: set up stdio (dup2) to pipes or client fd first...

    // TODO(macOS): Before execve, close all fds except the ones dup2’d to 0/1/2
    // and the required pipe ends. Iterate _listeners and _connections and close the rest.
    // We avoid F_SETFD on macOS per subject rules.

    execve(path, argv, envp);
    _exit(127);
}
*/

✅ Now:

Keep your final webserv.conf.

Keep your www/ structure and HTML/CSS ready.

⏳ When basic GET works

Test /, /static/style.css, /files/file1.txt.

(Optionally) write a tiny GET stress script and save it for later.

⏳ When autoindex works

Test /files/, /upload/, /trash/.

Maybe small GET stress on /files/.

⏳ When big file send works

Test /stress/small.html and /stress/large.bin.

Now GET stress on these two becomes meaningful.

⏳ When DELETE works

Test /trash/test.txt create + DELETE.

Optional simple DELETE stress.

⏳ When POST + upload work

Test /upload/foo.txt manually.

Only now:

POST stress to /upload/...

POST body stress to /stress/upload.

⏳ When CGI works

Test /cgi-bin/test.py.

Optional CGI stress.